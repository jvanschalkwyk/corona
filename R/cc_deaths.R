# Generated by LaTeX DogWagger Version 4.0.5 from file <NCTLL_500.tex>
# Date: [2020-7-26 17:40:3] 
# Do NOT edit this file. Edit the LaTeX source!!

# - <Section 5> - 
#' Plot country deaths by week, with various adjustments:
#'
#' Assumes the existence of the data frame ccdead where cc is one of AUT, BEL, BGR, CHE, CZE, DEUTNP, DNK, ESP, 
#'   EST, FIN, FRATNP, GBRTENW, GBR_SCO, HUN, ISL, ITA, LTU, LUX, NLD, NOR, PRT, SVK, SWE, or USA.
#' The unusual codes DEUTNP, FRATNP, GBRTENW, and GBR_SCO represent Germany, France, England+Wales and Scotland.
#' The default is GBRTENW, for reasons evident in the book. 
#' 
#' The columns in the frame stmf are just 'PopCode', 'Year', 'Week', and 'Deaths'. 
#' 
#'   Draws three graphs:
#'   1. Raw data with a linear regression line, over n years; 
#'   2. Data with secular adjustment; 
#'   3. Data adjusted for a 'summer baseline' using the "other n years of data" after
#'      secular adjustment.  
#' 
#' @param pdf=FALSE will not print to PDF
#' @param summerstart, summerend (which months, e.g. 6=June)
#' @param save Do we save the data as a CSV
#' @keywords corona deaths 
#' @export 
#' @examples 
#' country_dead( pdf=TRUE ) 
#' country_dead( cc='NZL', summerstart=12, summerend=2 ) 

# country codes <- https://www.nationsonline.org/oneworld/country_code_list.htm 
## must also supply month in which summer starts and ends (inclusive)

country_dead <- function ( cc = 'GBRTENW', pdf=FALSE, summerstart=6, summerend=8, save=FALSE ) 
{ ## CC <- toupper(cc); 
  # [here might 'decode' ccc to a better name]
  mytitle <- paste(cc , "Weekly Deaths"); 
  ccname <- paste(cc, '_weekly', sep=''); 

  PdfFilename <- paste(ccname, '_dead.pdf', sep=''); 
  SecularFilename <- paste(ccname, '_secular.pdf', sep=''); 
  AdjustedFilename <- paste(ccname, '_adjusted.pdf', sep=''); 

  ## formerly: 
  # CsvFilename <- paste(ccname, '.csv', sep=''); 
  # MYDEAD <- get( paste(cc, 'dead', sep='') ); # clumsy R translation of string (i.e. name) to frame
  MYDEAD <- stmf[ stmf$PopCode==cc, ]; 

  ccRows <- nrow(MYDEAD);

  ## For each row, WE NOW NEED TO insert a Date field based on year+month [hmm] 
  MinYear <- min(MYDEAD$Year); 
  MaxYear <- max(MYDEAD$Year); 
  ## MYDEAD$Wk <- 52*(MYDEAD$Year-MinYear) + (MYDEAD$Week-1); 
  ## ^^ what if there are 53 weeks in a given year? i.e. 2004, 2009, 2015 
  # We thus simply say:
  MYDEAD$Num <- seq(ccRows);
  startDate <- as.Date(ISOdate(MinYear, 1, 1)); # assumes 1 January [explore, hmm] cf. 1st Monday or Sunday ?
  MYDEAD$Date <- seq.Date(from=startDate, by=7, length.out=ccRows); 

  ## ccYears <- as.integer(ccRows/52); ## assumes 52 weeks per year [crude]
  ccYears <- MaxYear - MinYear; 
if(ccYears < 5)
  { stop( paste("Too few years =", ccYears, "for country", cc) );
  }; 
  YearTop <- ccYears * 52; # assumes first year starts at week 1 [check, hmm]

#########################################################
  secular_fix <- function (F) # F is the frame.
  { mylm <- lm(F$Deaths ~ F$Num);
    yint <- mylm$coefficients[1];
    slp <- mylm$coefficients[2]; 
    WTOT <- nrow(F); 
    F$secular <- F$Deaths * ( 1 + slp*(1+WTOT-F$Num)/yint ); 
    return(F);
  };
  ## summer, depending on month, M is a frame: [would be smarter to lookup, not supply; even have frame] 
if(summerstart < summerend) 
  { summer <- function(M, sStart, sEnd) # N hemisphere
      { M$summer <- as.integer(format(M$Date, '%m')); 
        M$summer <- (M$summer >= sStart) & (M$summer <= sEnd); 
        return(M); 
      }; 
  } else
  { summer <- function(M, sStart, sEnd)
      { M$summer <- as.integer(format(M$Date, '%m')); 
        M$summer <- (M$summer >= sStart) | (M$summer <= sEnd); 
        return(M); 
      }; 
  }; 
  #########################################################
  # look for secular change: 
  MYDEAD <- secular_fix(MYDEAD); 
  #####################################
  # eye candy with regression line. 
  corona_pdf(PdfFilename, 12, 7, pdf); 
  myplot <- ggplot( MYDEAD, aes(x=Date, y=Deaths)) + 
    labs(title=mytitle, x='Date', y='Deaths') + 
    geom_point() + geom_line() + geom_smooth(method='lm') + 
    scale_x_date(breaks="1 year", date_labels = "%Y") ;
  corona_print(myplot); 
  corona_pdf_off(PdfFilename, pdf, waitline=TRUE);  

  #########################################
  # with secular adjustment:
  corona_pdf(SecularFilename, 12, 7, pdf); 
  secplot <- ggplot( MYDEAD, aes(x=Date, y=secular)) + 
    labs(title=mytitle, x='Date', y='Deaths(adj)') + 
    geom_point() + geom_line() + geom_smooth(method='lm') + 
    scale_x_date(breaks="1 year", date_labels = "%Y") ;
  corona_print(secplot); 
  corona_pdf_off(PdfFilename, pdf, waitline=TRUE);

  ############################################
  # seasonal. To get summer:
  MYDEAD <- summer(MYDEAD, summerstart, summerend); 
  SumSecAvg <- mean( MYDEAD[ MYDEAD$summer, ]$secular ); 
  # the benchmark adjustment is the sum of other 9 most recent corresponding weeks  
  #   divided by 9 and then DIVIDED INTO the current value. 

  ######## Get week of year for each value [will be slightly off] and work out mean for each such week, over all years. 
  MYDEAD$bm <- MYDEAD$Week %% 52;
  weekmean <- tapply(MYDEAD$secular[1:YearTop], MYDEAD$bm[1:YearTop], mean);
  MYDEAD$expected <- MYDEAD$adjust <- weekmean[ 1+MYDEAD$bm ];

  # next, remove own value from mean: 
  MYDEAD$adjust[1:YearTop] <- (ccYears*MYDEAD$adjust[1:YearTop] - MYDEAD$secular[1:YearTop])/(ccYears-1); 
  ## ^ do not adjust final values over YearTop i.e. in 2020, as they haven't been included! 
  # we now want to replace MYDEAD$bm by the corresponding indexed value in BCH 
  # now normalise to SumSecAvg, the summer secular average. 
  MYDEAD$adjust = MYDEAD$adjust/SumSecAvg; 
  # finally, adjust
  MYDEAD$seasonal <- MYDEAD$secular/MYDEAD$adjust; 
  corona_pdf(AdjustedFilename, 12, 7, pdf); 
  mychart <- qic(x=MYDEAD$Date, y=MYDEAD$seasonal, chart='i',
          title='Seasonally Adjusted Deaths', xlab='Year', ylab='Deaths'); 
  print(mychart); 
  corona_pdf_off(AdjustedFilename, pdf); 

if(save)
  { write.csv(MYDEAD, file=CsvFilename);
  }; 
}
# -END OF FILE- 
